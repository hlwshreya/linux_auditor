---
# roles/oscap_remediation/tasks/main.yml

- name: Set timestamp for remediation
  set_fact:
    remediation_timestamp: "{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"
  delegate_to: localhost
  run_once: false

- name: Find latest ARF scan result for this host
  find:
    paths: "{{ reports_dir }}"
    patterns: "{{ ansible_distribution | lower }}-*-{{ inventory_hostname }}-*-arf.xml"
  register: scan_results
  delegate_to: localhost

- name: Fail if no scan results found
  fail:
    msg: "No scan results found for {{ inventory_hostname }} in {{ reports_dir }}. Run oscap_scan role first."
  when: scan_results.matched == 0

- name: Get latest scan
  set_fact:
    latest_scan: "{{ (scan_results.files | sort(attribute='mtime', reverse=True) | first).path }}"

- name: Set remediation file names
  set_fact:
    remediation_playbook: "{{ remediation_dir }}/{{ ansible_distribution | lower }}-{{ ansible_distribution_version }}-{{ inventory_hostname }}-{{ remediation_timestamp }}-remediation.yml"
    remediation_report: "{{ remediation_dir }}/{{ ansible_distribution | lower }}-{{ ansible_distribution_version }}-{{ inventory_hostname }}-{{ remediation_timestamp }}-report.txt"
    failed_rules_file: "{{ remediation_dir }}/{{ ansible_distribution | lower }}-{{ ansible_distribution_version }}-{{ inventory_hostname }}-{{ remediation_timestamp }}-failed-rules.txt"

- name: Ensure remediation directory exists
  file:
    path: "{{ remediation_dir }}"
    state: directory
    mode: '0755'
  delegate_to: localhost
  become: false

- name: Generate remediation playbook (failed rules only)
  shell: |
    oscap xccdf generate fix --fix-type ansible --output {{ remediation_playbook }} {{ latest_scan }}
  args:
    executable: /bin/bash
  delegate_to: localhost
  become: false
  register: generate_fix
  failed_when: generate_fix.rc != 0

- name: Extract failed rules using Python
  shell: |
    python3 << 'EOF'
    import xml.etree.ElementTree as ET
    tree = ET.parse("{{ latest_scan }}")
    root = tree.getroot()
    ns = {"xccdf": "http://checklists.nist.gov/xccdf/1.2"}
    failed = []
    
    for rr in root.findall(".//xccdf:rule-result", ns):
        result = rr.find("xccdf:result", ns) or rr.find("xccdf:r", ns)
        if result is not None and result.text and result.text.strip() == "fail":
            rule_id = rr.attrib.get("idref", "")
            if rule_id:
                failed.append(rule_id)
    
    if not failed:
        for rr in root.findall(".//rule-result"):
            result = rr.find("result") or rr.find("r")
            if result is not None and result.text and result.text.strip() == "fail":
                rule_id = rr.attrib.get("idref", "")
                if rule_id:
                    failed.append(rule_id)
    
    for rule in sorted(set(failed)):
        print(rule)
    EOF
  args:
    executable: /bin/bash
  delegate_to: localhost
  register: python_extraction
  changed_when: false
  failed_when: false

- name: Set failed rules list
  set_fact:
    failed_rules_list: "{{ python_extraction.stdout_lines | sort }}"
    total_failed_rules: "{{ python_extraction.stdout_lines | length }}"

- name: Fallback - Extract from remediation playbook if needed
  block:
    - name: Extract from playbook
      shell: grep -oP 'xccdf_org\.ssgproject\.content_rule_[a-zA-Z0-9_]+' {{ remediation_playbook }} | sort -u
      register: playbook_extraction
      delegate_to: localhost
      changed_when: false
    
    - name: Update failed rules
      set_fact:
        failed_rules_list: "{{ playbook_extraction.stdout_lines | sort }}"
        total_failed_rules: "{{ playbook_extraction.stdout_lines | length }}"
  when: total_failed_rules | int == 0

- name: Create failed rules list file
  copy:
    content: |
      Failed Rules (Sorted Alphabetically)
      ====================================
      Total: {{ total_failed_rules }}
      Source: {{ latest_scan | basename }}
      Date: {{ ansible_date_time.iso8601 }}
      
      {% for rule in failed_rules_list %}
      {{ "%04d" | format(loop.index) }}. {{ rule }}
      {% endfor %}
    dest: "{{ failed_rules_file }}"
    mode: '0644'
  delegate_to: localhost
  become: false

- name: Create remediation report
  copy:
    content: |
      OpenSCAP Remediation Report
      ===========================
      Host: {{ inventory_hostname }} ({{ ansible_distribution }} {{ ansible_distribution_version }})
      Scan: {{ latest_scan | basename }}
      Generated: {{ ansible_date_time.iso8601 }}
      Failed Rules: {{ total_failed_rules }}
      
      Files Generated:
      - Playbook: {{ remediation_playbook }}
      - Rules List: {{ failed_rules_file }}
      
      {% if total_failed_rules | int > 0 %}
      Failed Rules:
      {% for rule in failed_rules_list %}
      {{ loop.index }}. {{ rule | regex_replace('^xccdf_org\\.ssgproject\\.content_rule_', '') }}
      {% endfor %}
      
      Next Steps:
      1. Review: {{ remediation_playbook }}
      2. Apply: ansible-playbook {{ remediation_playbook }}
      3. Re-scan: ansible-playbook playbooks/oscap_scan.yml -l {{ inventory_hostname }}
      {% else %}
      âœ“ System is compliant - no remediation needed
      {% endif %}
    dest: "{{ remediation_report }}"
    mode: '0644'
  delegate_to: localhost
  become: false

- name: Set apply command
  set_fact:
    apply_msg: "{{ 'Apply: ansible-playbook ' + remediation_playbook if total_failed_rules | int > 0 else 'System is compliant' }}"

- name: Display summary
  debug:
    msg:
      - "Remediation Complete: {{ inventory_hostname }}"
      - "Failed rules: {{ total_failed_rules }}"
      - "Playbook: {{ remediation_playbook | basename }}"
      - "Report: {{ remediation_report | basename }}"
      - "{{ apply_msg }}"

- name: Apply remediation if auto_remediate is true
  include_tasks: apply_remediation.yml
  when: 
    - auto_remediate | default(false) | bool
    - total_failed_rules | int > 0
